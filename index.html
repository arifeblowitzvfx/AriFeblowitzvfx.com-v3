function buildBannerDeferred(){
  if (loaded.banner || !window.__tilesData) return;
  loaded.banner = true;

  const { pro = [], ride = [], per = [] } = window.__tilesData;

  // Helper: pick top N by prio, with fallback to first N if prios are all zero
  const pickTop = (arr, n) => {
    if (!arr.length) return [];
    const sorted = arr.slice().sort((a,b) => (b.prio||0) - (a.prio||0));
    const allZero = sorted.every(t => (t.prio||0) === 0);
    return (allZero ? arr.slice(0, n) : sorted.slice(0, n));
  };

  // Choose how many from each bucket; tweak to taste
  const pSel = pickTop(pro, 12);
  const rSel = pickTop(ride, 8);
  const vSel = pickTop(per, 12);

  // If still too few, backfill from whateverâ€™s left
  const backfill = (need) => {
    const pool = [...pro, ...ride, ...per];
    const used = new Set([...pSel, ...rSel, ...vSel]);
    return pool.filter(x => !used.has(x)).slice(0, need);
  };

  let tiles = [];
  const L = Math.max(pSel.length, rSel.length, vSel.length);
  for (let i=0; i<L; i++){
    if (pSel[i]) tiles.push(pSel[i]);
    if (rSel[i]) tiles.push(rSel[i]);
    if (vSel[i]) tiles.push(vSel[i]);
  }
  if (tiles.length < 12) tiles = tiles.concat(backfill(12 - tiles.length));

  if (!tiles.length){
    // last-ditch: show personal tiles or bail quietly
    tiles = per.slice(0, 12);
    if (!tiles.length) return;
  }

  fillBanner(tiles);

  // ---- Lazy-load failsafe: force any still-lazy images to load after a moment ----
  setTimeout(() => {
    document.querySelectorAll('#bannerScroll img[data-src]').forEach(img => {
      img.src = img.dataset.src;
      img.removeAttribute('data-src');
      if (img.dataset.srcset) {
        img.srcset = img.dataset.srcset;
        img.removeAttribute('data-srcset');
      }
    });
  }, 700);
}
